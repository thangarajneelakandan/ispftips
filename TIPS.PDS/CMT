/* --------------------  rexx procedure  ------------------------- *
 * Name:      CMT                         Version 3.5    09/16/16  */
                                          vernbr="3.5"
/*                                                                 *
 * Function:  Create a documentation 'box' within the object       *
 *            being edited. The syntax of the comment box          *
 *            is based on the object type which is determined by   *
 *            this REXX or set by the user via the popup panel.    *
 *                                                                 *
 * Syntax1:   Entered on Command line to add comments.             *
 *            CMT I,B,text          (all parameters are optional)  *
 *                                  (and must be separated by a ,) *
 *            I = nbr 1-65, C (Center) or R (Right justify)        *
 *                The number of spaces to Indent added text box    *
 *                or if text should be Centered or Right justified.*
 *                (Default is 0)                                   *
 *            B = V,S,F or blank  (BOXSIZE)                        *
 *                V = uses a Variable box based on longest line    *
 *                F = uses a Fixed box size (70 characters long)   *
 *                S = same as F (Fixed) S = a Set size             *
 *                (See Syntax2 for means to set defaults)          *
 *            Text = optional one line of text to include.         *
 *                (Default displays a popup panel for text entry)  *
 *                (and allows an unlimited number of lines.)       *
 *                                                                 *
 * Syntax2:   Entered on Command line to set/change default values *
 *            CMT SET <parm to set> <parm value>                   *
 *                                                                 *
 *            parm to set: INDENT  or abbrev of (set indent value) *
 *                       : BOXSIZE or abbrev of (set box size)     *
 *                       : CHARIZE or abbrev of (set boxing char)  *
 *            parm value : for INDEND either 1 - 65, C or R        *
 *                         for BOXSIZE either F,S or V             *
 *                       : for CHARIZE any character is valid      *
 *                                                                 *
 * Syntax3:   Entered as Line Command (see NOTE below)             *
 *            CMT        (all parameters default, panel displayed) *
 *                                                                 *
 *            NOTE: A line command macro is required to utilize    *
 *            syntax option 3. LINEMAC is include in this package  *
 *            but requires the use of Doug Nagel's LMAC or UMAC.   *
 *            Please see http://www.mindspring.com/~somebody/      *
 *            "A few ISPF or OS/390 tools and toys" for a complete *
 *            desciption of how to use and setup either LMAC or    *
 *            UMAC so the LINEMAC macro may be called to process   *
 *            user defined line commands.                          *
 *                                                                 *
 * Author:    Lionel B. Dyck                                       *
 *            Internet: lbdyck@gmail.com                           *
 *                                                                 *
 * Additions: Bill George                                          *
 *            Internet: billgeo@bigfoot.com                        *
 *                                                                 *
 * History:                                                        *
 *            09/16/16 - Change REXX comment char to |             *
 *            Ver 3.5    Lionel B. Dyck                            *
 *                                                                 *
 *            06/14/16 - Add Comment support for Shell Scripts     *
 *            Ver 3.4    Lionel B. Dyck                            *
 *                                                                 *
 *            09/09/13 - Add Comment support for ISPF Skeletons    *
 *            Ver 3.3    Lionel B. Dyck                            *
 *                                                                 *
 *            06/20/07 - Expand width of comments thanks to        *
 *            Ver 3.2    Bill Lambert                              *
 *                                                                 *
 *            06/22/06 - Add support for PLI thanks to             *
 *            Ver 3.1    Hans Geiser                               *
 *                     - Fix undefined variable when using on new  *
 *                       (empty) member                            *
 *                     - Correction for SAS and PLI usage for Var  *
 *                       size comment boxes                        *
 *                                                                 *
 *            01/16/06 - Updated doc and help to indicate that a   *
 *            Ver 3.0    target line must be specified.            *
 *                                                                 *
 *            01/24/03 - Updated to deal with a COBOL profile      *
 *            Ver 2.9    of NUMERS ON COBOL                        *
 *            BG       - changed method of producing in-line       *
 *                       panels. Less error prone method.          *
 *                                                                 *
 *            02/17/01 - Update to check for data type.            *
 *            Ver 2.8  - check for EXEC, CNTL, SAS, and ASM        *
 *            LBD      - Added test for filename                   *
 *                                                                 *
 *            01/30/01 - Updated help for the CMT command.         *
 *            Ver 2.7  - Added   help for the CMT panel.           *
 *            BG       - Added FIXLEN parm. It controls the size   *
 *                       of a Fixed length box. It defaults to 57  *
 *                       and has a max of 60. It may be set via    *
 *                       the panel or CMT SET F # command.         *
 *                                                                 *
 *            01/29/01 - Updated panel to show Fixed option.       *
 *            Ver 2.6    Updated error message if no destination   *
 *            BG         was set to indicate help is available via *
 *                       the CMT HELP command.                     *
 *                                                                 *
 *            01/25/01 - Added F (Fixed) as valid BOXSIZE parm.    *
 *            Ver 2.5    Works same as S, might be more intuitive. *
 *            BG         Updated HELP accordingly.                 *
 *                     - Added C (CENTER) and R (Right Justify)    *
 *                       as valid INDENT parameters.               *
 *                       These comment box placements are calc'ed  *
 *                       off the object's RIGHT BOUNDS setting.    *
 *                     - Added INDENT prompt to panel.             *
 *                     - Added Version number to panel.            *
 *                     - Move the panel definition in-line.        *
 *                       (member CMTPANEL not required now)        *
 *                     - Fixed bug that displayed the Version nbr  *
 *                       When CMT V (variable boxsize) entered.    *
 *                     - Fix bug that didn't set the BOXSIZE parm  *
 *                       correctly in the panel if BOXSIZE sent    *
 *                       with command.  ie, CMT 5,V                *
 *                                                                 *
 *            01/17/01 - Fixed bug in CANCEL process.              *
 *            Ver 2.4  - Added code to allow parms in any order    *
 *            BG       - Adjusted order of some object type tests  *
 *                     - Fixed bug in check for special functions  *
 *                       chgd Pos(functn_ck.. to Wordpos(functn_ck *
 *                     - Added code to add an empty box with one   *
 *                       line if PF3 entered with no text entered. *
 *                     - Added error msg for invalid INDENT value. *
 *                     - Added logic to allow for debugging.       *
 *                     - Added ability to change box outlining char*
 *                       CMT SET CHARBOX (or C) to change default. *
 *                     - Added boxing character and BOXSIZE parms  *
 *                       to the panel for user changing.           *
 *                     - Updated some doco typos and added some    *
 *                       comments on use of LINEMAC macro included *
 *                                                                 *
 *            01/16/01 - Moved Doug Nadel's Linemac into this code *
 *            01/11/01 - Added SAS as an option.                   *
 *            01/08/01 - Added flexibility to create comments in   *
 *                       he proper syntax for different object     *
 *                       types. CLIST,REXX,C,COBOL,DOC,ASM,PANELS  *
 *                     - Added additional box type via a new parm. *
 *                     - Added logic to store default values for   *
 *                       the INDENT and BOXSIZE parms via the      *
 *                       CMT SET <parms> function.                 *
 *                     - Added code to function with Doug Nagel's  *
 *                       LINEMAC line command function so CMT may  *
 *                       be entered as a line command.             *
 *                     - Added a HELP function.                    *
 *                     - Added a VERSION function.                 *
 *            01/03/01 - Convert to use table                      *
 *            12/22/00 - Added. for blank lines in popup           *
 *            12/22/00 - Added # for indent                        *
 *            12/22/00 - Creation                                  *
 * --------------------------------------------------------------- */
  Address Isredit
 "MACRO (TEXT) NOPROCESS"
  Address Ispexec "Control Errors Return"
 /* ----------------------------- *
  * Check for a debugging request *
  * ----------------------------- */
  Parse Var text text '<<' TraceVal
  if TraceVal > '' then x = Trace(TraceVal)
  text = Strip(text)

 /* -------------------- *
  * Init Some Variables  *
  * -------------------- */
  Parse Value "" with null cmt_suf indent boxsize ddname
  cmt_last = "*"
  valid_box_values = "F S V"
  Panels_Created = 0
  x_rc = 0

 /* --------------------------------------------------------- *
  * Save the display position so it may be restored when done *
  * as subsequent processing may do havoc to its position.    *
  * --------------------------------------------------------- */
  top = null
 '(top,bot) = DISPLAY_LINES'
  "LABEL" top "= .SAV 0"
 "(holdrow,holdcol) = CURSOR"                /* save cursor position */
 if top = null then top = 1

 /* --------------------------------- *
  * Check/Arrange entered parameters. *
  * Process special command if found. *
  * --------------------------------- */
  if Length(text) > 0 then do
     Parse Value text with indent "," boxsize "," text2
     Parse Upper VAR indent functn_ck .

    /* -------------------------------------- *
     * Process special commands.              *
     * CMT ends if special command processed. *
     * -------------------------------------- */
     if functn_ck = "SET" then do
        Call Set_CMT_Default
        Signal Exit_Macro
     end

     if Abbrev("HELP",functn_ck,1),
     |  functn_ck =  "?" then do
        Call Get_Help
        Signal Exit_Macro
     end

     if Abbrev("VERSION",functn_ck,2) then do
        zedsmsg = "CMT Version" vernbr
        zedLmsg = "CMT Version" vernbr
        Address Ispexec "Setmsg Msg(isrz000)"
        Signal Exit_Macro
     end

    /* ---------------------------------------- *
     * Arrange parameters into processing order *
     * of indent,boxsize,test                   *
     * ---------------------------------------- */
     Call Arrange_Parameters

     end
  else
   /* ----------------------------------------- *
    * No parameters entered, use default values *
    * ----------------------------------------- */
     Call Get_Default_Values

 /* ------------------------------------ *
  * Use defaults for any null parameters *
  * ------------------------------------ */
  if indent  = null then indent  = cmtdfInd
  if boxsize = null then boxsize = cmtdfBox
  Upper boxsize

 /* ------------------------------*
  * Test for a valid INDENT value *
  * ------------------------------*/
  if Datatype(indent) = "NUM",
  &  indent > 65 then do
     zedsmsg = null
     zedlmsg = Left("ERROR: INDENT value," indent "invalid.",81),
             "Must be between 0 - 65,  C=Center or  R=Right Justify"
     Address Ispexec "Setmsg Msg(isrz000)"
     x_rc = 8
     Signal Exit_Macro
  end

 /* --------------------------------- *
  * Test for a target destination set *
  * via an "A" or "B" line command.   *
  * --------------------------------- */
 "PROCESS DEST"
  dest_rc = rc

  if dest_rc = 0 then
    "(DEST) = LINENUM .ZDEST"

  else do
    /* ---------------------------------------------------- *
     * "A" or "B" line destination not found, check if      *
     * called via LINEMAC, ("PROCESS DEST" gets a non 0 rc) *
     * look for a .CMT line LABEL set in LINEMAC.           *
     * ---------------------------------------------------- */
    "Locate .CMT"

     if rc = 0 then do
      /* ------------------------------ *
       * Set the target destination and *
       * RESET LABEL set in LINEMAC     *
       * ------------------------------ */
      "(DEST) = LINENUM .ZCSR"
      "Reset label" DEST-1 DEST+1
       end
     else do
        zedsmsg = ""
        zedlmsg =,
           Left("A destination line must be specified, try again.",81),
           Left("Use an A(After) or B(Before) on a line in your data.",
                 ,81),
                "For help, enter CMT HELP"
        Address Ispexec "Setmsg Msg(ISRZ001)"
        x_rc = 8
        Signal Exit_Macro
     end
  end

  Call Determine_Object_Type

 /* ---------------------------------------------------------- *
  * Send message if object type is not valid for indentation.  *
  * NOTE: ASM & JCL require chars in column 1 but if an indent *
  *       value is input, another '*' is placed at the indent  *
  *       position to start an indented box at that point.     *
  * ---------------------------------------------------------- */
  if Pos(mbr_type,"COBOL") > 0,
  &  indent > 0 then do
     zedsmsg = ""
     zedlmsg = "Indentation parm of," indent,
               "is not valid for this mbr type"
     Address Ispexec "Setmsg Msg(isrz000)"
  end

 /* ------------------------ *
  * if no TEXT entered then  *
  * display the popup panel. *
  * ------------------------ */
  if Length(text) = 0 then Call Process_Via_Panel

 /* ---------------------------------------------------- *
  * else just add the provided line - (No panel input)   *
  * ---------------------------------------------------- */
  else do
     boxlen = Length(text)
     Call Setup_Member_Type_Parameters
     Call do_box first_line
     Call do_line text
  end

 /* ----------------------------------------- *
  * Put out the last line of the comment box. *
  * ----------------------------------------- */
  Call do_box last_line

Exit_Macro:

 "locate .sav"
 "(dest) = linenum .ZCSR"
 "reset label" top-1 top+1
 "cursor = (holdrow,holdcol)"               /* restore cursor postn */
 /* ------------------------------------- *
  * Deallocate panel's temporary library. *
  * ------------------------------------- */
  if ddname \= null then do
     Address Ispexec "Libdef ispplib"
     Address Tso "Free f("ddname")"
  end

Exit x_rc

             /*-------------------------------            /* Ge150606 */
                C A L L E D   R O U T I N E S
               -------------------------------*/          /* Ge150606 */

/*===========================================================*
* Routine: Process_Via_Panel:                                *
*   Display a popup panel for the user to input comments.    *
*   Process the comments and/or commands enntered.           *
*===========================================================*/
Process_Via_Panel:

   Call Create_Panels

  /* ---------------------- *
   * Create the ISPF Table  *
   * and prefill in 150 rows*
   * ---------------------- */
   Address Ispexec
  "Tbcreate cmt Names(rxline)"
   rxline = null

   do i = 1 to 150
     "Tbadd cmt"
   end
  "Tbtop cmt"
  "Addpop"

  /* ---------------------- *
   * Now display the table  *
   * ---------------------- */
   trc = 0
   cmt_suf = null
   do until trc > 4
     "Tbdispl cmt Panel(cmtpanel)"
      trc = rc

     /* ---------------- *
      * Test for Cancel  *
      * ---------------- */
      if Abbrev("CANCEL",zcmd,1) then do
        "Tbend cmt"
         Signal Exit_Macro
      end

     /* ---------------- *
      * Test for Insert  *
      * ---------------- */
      if Abbrev("INSERT",WORD(zcmd,1),1) = 1 then do
         Parse Value zcmd with x count
         zcmd   = null
         rxline = null
        "Tbbottom cmt"
         do i = 1 to count
           "Tbadd cmt"
         end
        "Tbtop cmt"
        "Tbskip cmt number("ztdtop")"
      end

     /* ----------------------------------------------- *
      * if user requests to use parameters as defaults, *
      * store the default values in the PROFILE pool.   *
      * ----------------------------------------------- */
      if Translate(setdflt) = "Y" then do
         cmtdfInd = indent
         cmtdfBox = boxsize
        "Vput (cmtdfInd cmtdfBox cmtdfChr cmtdfFix) profile"
      end

     /* ------------------------------ *
      * Process multiple rows of text  *
      * ------------------------------ */
     "Tbput cmt"
      do i = 1 to ztdsels-1
        "Tbdispl cmt"
        "Tbput cmt"
      end
   end

  /* ------------------------------------------------------ *
   * end of Table Display                                   *
   * Remove popup and go to top of table.                   *
   * Check if the member type has been changed by the user. *
   * ------------------------------------------------------ */
  "Rempop"
  "Tbtop cmt"

   if MbrType /= mbr_type then do
      mbr_type = MbrType
      boxlen = Length(text)
      Call Setup_Member_Type_Parameters
   end

  /* --------------------------------------------------------- *
   * Process all entered rows of information by loading a      *
   * REXX STEM variable with the text lines and checking for   *
   * the longest line as we go incase a Variable box required. *
   * --------------------------------------------------------- */
   cmts. = null
   Parse Value '0' WITH 1 cnt 1 boxlen 1 blank_cnt

   Do Forever
     "Tbskip cmt"
      if rc > 0 then Leave

     /* ----------------------------------------------------- *
      * if text found on line, check if its the longest line. *
      * Start the blank line count over.                      *
      * ----------------------------------------------------- */
      if Length(rxline) > 0 then do
         len = Length(rxline)
         if len > boxlen then boxlen = len
         blank_cnt = 0
         end
      else do

        /* ------------------------------------------------------ *
         * Leave if we have found the 2nd consecutive blank line. *
         * ------------------------------------------------------ */
         blank_cnt = blank_cnt + 1
         if blank_cnt > 1 then do
            cnt = cnt - 1
            Leave
         end
      end
     /* --------------------- *
      * Save the comment text *
      * --------------------- */
      cnt = cnt + 1
      cmts.cnt = rxline
   end

   if cnt = 0    then cnt = 1
   if boxlen = 0 then boxlen = 55

  /* -------------------- *
   * Close out the table  *
   * -------------------- */
  "Tbend cmt"

  /* ---------------------------------- *
   * Write out the comment box.         *
   * Last boarder line for box written  *
   * out upon RETURN from this routine. *
   * ---------------------------------- */
   Address Isredit
   Call Setup_Member_Type_Parameters
   Call do_box first_line

   do i = 1 to cnt
      Call do_line cmts.i
   end

Return

/*===========================================================*
* Routine: Do_Line:                                          *
* This routine sets up the comment line between * and        *
* then inserts it into the code.                             *
*===========================================================*/
Do_Line:

  Parse Arg data
  if data = "." then data = " "
  data = indent_spc || cmt_chars Left(data,boxlen) cmt_last""cmt_suf
 "Line_After" dest "= (data)"
  dest = dest + 1

Return

/*===========================================================*
* Routine: Do_Box:                                           *
* Do_Box Routine is called to output the first and last      *
* lines of the comment box.                                  *
*===========================================================*/
Do_Box:
  Parse Arg data
 "Line_After" dest "= (data)"
  dest = dest + 1
Return

/*===========================================================*
* Routine: Determine_Object_Type:                            *
*   Determine the type of member being edited                *
*   so the proper comment syntax may be used.                *
*============================================================*/
Determine_Object_Type:

  mbr_type = null
 /* ----------------------------------------------- *
  * Check if the member type can be determined from *
  * the data found in the first line of the member. *
  * if determined, Exit the routine.                *
  * ----------------------------------------------- */
 '(line1) = LINE 1'
  Upper Line1
  Select
     When Left(line1,2) = '//'       then mbr_type = 'JCL'
     When Left(line1,1) = '#'        then mbr_type = 'SHELL'
     When Wordpos('REXX',line1) > 0  then mbr_type = 'REXX'
     Otherwise Nop
  end

  if mbr_type /= null then Signal Type_Exit

 /* -------------------------- *
  * Ad hoc CLIST/PANEL checks  *
  * -------------------------- */
 "Find first X'50E2E3D9'"                          /* &STR(    */
  if rc = 0 then do
     mbr_type = 'CLIST'
     Signal Type_Exit
  end

 "Find first X'50E2E4C2E2E3D94D'"                  /* &Substr( */
  if rc = 0 then do
     mbr_type = 'CLIST'
     Signal Type_Exit
  end

 "Find first X'50D3C1E2E3C3C3'"                    /* &LASTCC  */
  if rc = 0 then do
     mbr_type = 'CLIST'
     Signal Type_Exit
  end

 "Find first ')ATTR '"
  if rc = 0 then do
     mbr_type = 'PANEL'
     Signal Type_Exit
  end

 /* ------------------ *
  * Ad hoc ASM checks  *
  * ------------------ */
 "Find first 'DSECT ' 10 20"
  if rc = 0 then do
     mbr_type = 'ASM'
     Signal Type_Exit
  end

 "Find first 'DS  ' 10"
  if rc = 0 then do
     mbr_type = 'ASM'
     Signal Type_Exit
  end

 "Find first 'MVC  ' 10"
  if rc = 0 then do
     mbr_type = 'ASM'
     Signal Type_Exit
  end

 /* ------------------- *
  * Ad hoc REXX checks  *
  * ------------------- */
 "Find first 'Wordpos('"
  if rc = 0 then do
     mbr_type = 'REXX'
     Signal Type_Exit
  end

 "Find first ' Parse v'"
  if rc = 0 then do
     mbr_type = 'REXX'
     Signal Type_Exit
  end

 "Find first ' Parse u'"
  if rc = 0 then do
     mbr_type = 'REXX'
     Signal Type_Exit
  end

 "Find first ' address i'"
  if rc = 0 then do
     mbr_type = 'REXX'
     Signal Type_Exit
  end

 "Find first ' address t'"
  if rc = 0 then do
     mbr_type = 'REXX'
     Signal Type_Exit
  end

 /* ------------------- *
  * Ad hoc COBOL checks *
  * ------------------- */
 "Find first 'IDENTIFICATION DIVISION.' 8"
  if rc = 0 then do
     mbr_type = 'COBOL'
     Signal Type_Exit
  end

 "Find first ' 01 ' 7"
  if rc = 0 then do
     mbr_type = 'COBOL'
     Signal Type_Exit
  end

 "Find first ' PIC X(' 30 60"
  if rc = 0 then do
     mbr_type = 'COBOL'
     Signal Type_Exit
  end

 /* --------------- *
  * Ad hoc C checks *
  * --------------- */
 "Find first 'stdio.h'"
  if rc = 0 then do
     mbr_type = 'C'
     Signal Type_Exit
  end

/* --------------------------- *
 * Test for ISPF Skeleton Type *
 * --------------------------- */
 "Find first ')CM'"
 if rc = 0 then do
    mbr_type = "SKEL"
     Signal Type_Exit
     end

 "Find first ')DO'"
 if rc = 0 then do
    mbr_type = "SKEL"
     Signal Type_Exit
     end

 "Find first ')I'"
 if rc = 0 then do
    mbr_type = "SKEL"
     Signal Type_Exit
     end

 "Find first ')SE'"
 if rc = 0 then do
    mbr_type = "SKEL"
     Signal Type_Exit
     end

/* --------------------------------------------------------- *
 * Test for SAS Language Type                                *
 * --------------------------------------------------------- */
 "Find first t'RUN;'"
  if rc = 0 then do
     mbr_type = "SAS"
     Signal Type_Exit
     end

 /* ------------------ *                                  /* Ge150606 */
  * Ad hoc PLI checks  *                                  /* Ge150606 */
  * ------------------ */                                 /* Ge150606 */
 "FIND FIRST 'DCL '"                                      /* Ge150606 */
  if rc = 0 then do                                       /* Ge150606 */
     mbr_type = 'PLI'                                     /* Ge150606 */
     Signal Type_EXIT                                     /* Ge150606 */
  end                                                     /* Ge150606 */
                                                          /* Ge150606 */
 "FIND FIRST 'OPTIONS(MAIN'"                              /* Ge150606 */
  if rc = 0 then do                                       /* Ge150606 */
     mbr_type = 'PLI'                                     /* Ge150606 */
     Signal Type_EXIT                                     /* Ge150606 */
  end                                                     /* Ge150606 */
                                                          /* Ge150606 */
 "FIND FIRST 'CALL PLIRET'"                               /* Ge150606 */
  if rc = 0 then do                                       /* Ge150606 */
     mbr_type = 'PLI'                                     /* Ge150606 */
     Signal Type_EXIT                                     /* Ge150606 */
  end                                                     /* Ge150606 */
                                                          /* Ge150606 */
 "FIND FIRST ' BUILTIN'"                                  /* Ge150606 */
  if rc = 0 then do                                       /* Ge150606 */
     mbr_type = 'PLI'                                     /* Ge150606 */
     Signal Type_EXIT                                     /* Ge150606 */
  end                                                     /* Ge150606 */
                                                          /* Ge150606 */
 /* ----------------------------------------------- *
  * Check type based on a node of the dataset name  *
  * ----------------------------------------------- */
 '(dsname) = dataset'
  if Pos('ASM',dsname)   > 0  then mbr_type = 'ASM'
  if Pos('CLIST',dsname) > 0  then mbr_type = 'CLIST'
  if Pos('CNTL',dsname)  > 0  then mbr_type = 'JCL'
  if Pos('EXEC',dsname)  > 0  then mbr_type = 'REXX'
  if Pos('REXX',dsname)  > 0  then mbr_type = 'REXX'
  if Pos('SAS',dsname)   > 0  then mbr_type = 'SAS'
  if Pos('PLI',dsname)   > 0  then mbr_type = 'PLI'   /* Ge150606 */
  if Pos('SKEL',dsname)  > 0  then mbr_type = 'SKEL'
  if mbr_type \= null then Signal Type_Exit

 /* -------------------- *
  * Default to DOC type  *
  * -------------------- */
  mbr_type = 'DOC'

Type_Exit:
 'reset'
  MbrType = Mbr_Type                       /* Setup panel's disp var */

Return

/*========================================================*
* Routine: Setup_Member_Type_Parameters                   *
*   Setup processing parameters based on the member type. *
*========================================================*/
Setup_Member_Type_Parameters:

 /* ----------------------------------------------- *
  * Set 'boxlen' value for a Fixed length box type. *
  * Set character used for the box outside borders. *
  * ----------------------------------------------- */
  if Pos(boxsize,'SF') > 0 then boxlen = cmtdfFix
  dash_char  = cmtdfChr
  dash_line  = Left(dash_char,boxlen,dash_char)

 /* ------------------------------------------------------ *
  * if Centering requested, determine indent value to use. *
  * Centering is based on the objects RIGHT BOUNDS value.  *
  * ------------------------------------------------------ */
  if Translate(indent) = 'C' then do
     Address Isredit "(,rbnds) = BOUNDS"
     indent = (rbnds - boxlen - 6) % 2
  end

 /* ---------------------------------------------------- *
  * if RIGHT justify requested, determine indent value.  *
  * Calculation based on the objects RIGHT BOUNDS value. *
  * ---------------------------------------------------- */
  right_just = 0
  if Translate(indent) = 'R' then do
     right_just = 1
     Address Isredit "(,rbnds) = BOUNDS"
     indent = rbnds - (boxlen + 6)
  end

 /* --------------------------------------------------------- *
  * Setup the comment box syntax appropriate for the mbr type *
  * --------------------------------------------------------- */
  Select
     When mbr_type = 'ASM' then do
          if right_just then indent = indent + 2
         /* --------------------------------------- *
          * Setup special indent for assembler type *
          * --------------------------------------- */
          if indent > 1 then do
             cmt_chars  = "*"
             indent_spc = "*"Left(null,indent-1)
             end
          else do
             cmt_chars  = null
             indent_spc = "*"
             end
          first_line = indent_spc||cmt_chars dash_line "*"
          last_line  = indent_spc||cmt_chars dash_line "*"
          end
     When mbr_type = 'CLIST',
        | mbr_type = 'PANEL' then do
          cmt_chars  = "/*"
          cmt_suf    = "/"
          indent_spc = Left(null,indent)
          first_line = indent_spc"/*" dash_line "*/"
          last_line  = indent_spc"/*" dash_line "*/"
          end
     When mbr_type = 'COBOL' then do
         "(stat,fmt) = NUMBER"
          cmt_chars  = "*"
          if Pos("COBOL",fmt) > 0 then
             indent_spc = "*"Left(null,indent)
          else
             indent_spc = "      *"Left(null,indent)
          first_line = indent_spc"*" dash_line "*"
          last_line  = first_line
          end
     When mbr_type = 'JCL'   then do
         /* --------------------------------- *
          * Setup special indent for JCL type *
          * --------------------------------- */
          if indent > 3 then do
             cmt_chars  = "*"
             indent_spc = "//*"Left(null,indent-1)
             end
          else do
             cmt_chars  = null
             indent_spc = "//*"
             end
          first_line = indent_spc||cmt_chars dash_line "*"
          last_line  = indent_spc||cmt_chars dash_line "*"
          end
     When mbr_type = 'SKEL'  then do
         /* ---------------------------------- *
          * Setup special indent for SKEL type *
          * ---------------------------------- */
          cmt_chars  = "*"
          cmt_chars  = null
          indent_spc = ")CM *"
          first_line = indent_spc||cmt_chars dash_line "*"
          last_line  = indent_spc||cmt_chars dash_line "*"
          end
     When mbr_type = 'REXX',
        | mbr_type = 'C'     then do
          cmt_chars  = " |"
          cmt_last   = "|"
          indent_spc = Left(null,indent)
          first_line = indent_spc"/*" dash_line "*"
          last_line  = indent_spc" *" dash_line "*/"
          end
     When mbr_type = 'SHELL' then do                    /* lbd */
          cmt_chars  = "# "                             /* lbd */
          cmt_suf    = "#"                              /* lbd */
          cmt_last   = ""                               /* lbd */
          indent_spc = Left(null,indent)                /* lbd */
          first_line = indent_spc"# " dash_line "#"     /* lbd */
          last_line  = indent_spc"# " dash_line "#"     /* lbd */
          end                                           /* lbd */
     When mbr_type = 'SAS' then do
          cmt_chars  = "*"
          cmt_suf    = ";"
          indent_spc = Left(null,indent)
          first_line = indent_spc"*" dash_line "*;"
          last_line  = indent_spc"*" dash_line "*;"
          end
     When mbr_type = 'PLI' then do                        /* Ge150606 */
          if indent > 1 then do                           /* Ge150606 */
             cmt_chars  = " *"                            /* Ge150606 */
             indent_spc = Left(null,indent-1)             /* Ge150606 */
             end                                          /* Ge150606 */
          else do                                         /* Ge150606 */
             cmt_chars  = " *"                            /* Ge150606 */
             indent_spc = " "                             /* Ge150606 */
             end                                          /* Ge150606 */
          first_line = indent_spc"/*" dash_line "*"       /* Ge150606 */
          last_line  = indent_spc" *" dash_line "*/"      /* Ge150606 */
          end                                             /* Ge150606 */
     Otherwise do
          if right_just then indent = indent + 2
          cmt_chars  = "*"
          indent_spc = Left(null,indent)
          first_line = indent_spc||cmt_chars dash_line "*"
          last_line  = indent_spc||cmt_chars dash_line "*"
          end
  end

Return

/*=========================================================*
 * Routine: Set_CMT_Defaults                               *
 * This routine processes a CMT SET function to set a      *
 * user's default value for the INDENT or BOXSIZE parms.   *
 * if a current setting is not found for these, they are   *
 * defaulted to INDENT = 0 and BOXSIZE = S (Set size)      *
 *=========================================================*/
Set_CMT_Default:

  Parse Upper VAR indent cmd parm_id hlddfval

  Call Get_Default_Values

  Error = null
  Address Ispexec

  Select
  /* ------------------ *
   * Set INDENT default *
   * ------------------ */
     When Left(parm_id,1) = "I" then do
          parm_id  = "Indent"
          if Datatype(hlddfVal) = "NUM" then
             if hlddfInd < 66 then
                cmtdfInd = hlddfVal
             else
                Error="value must be a nbr 1-65, C=Center  R=Rt Justify"
          else
            if Pos(hlddfVal,"CR") > 0 then
                cmtdfInd = hlddfVal
            else
               Error="value must be a nbr 1-65, C=Center  R=Rt Justify"
          end /*when*/

  /* ------------------- *
   * Set BOXSIZE default *
   * ------------------- */
     When Left(parm_id,1) = "B" then do
          parm_id  = "BOXSIZE"
          if Pos(hlddfVal,"FSV") > 0 then
             cmtdfBox = hlddfVal
          else
             Error = "must be F or S (Fixed or Set) or V (Variable)"
          end

  /* ------------------------ *
   * Set the BOX CHAR default *
   * ------------------------ */
     When Left(parm_id,1) = "C" then do
          parm_id  = "CHARBOX"
          cmtdfChr = hlddfVal
          end

  /* -------------------------- *
   * Set the FIX LENGTH default *
   * -------------------------- */
     When Left(parm_id,1) = "F" then do
          parm_id  = "FIXLEN"
          if Datatype(hlddfVal) = "NUM" then
             if hlddfInd < 61 then
                cmtdfFix = hlddfVal
             else
                Error = "value must be a number from 1 - 75"
          else
                Error = "value must be a number from 1 - 75"
          end

  /* ------------------------ *
   * Error: no SET parameters *
   * ------------------------ */
     When parm_id = null then do
          parm_id = "<blank>"
          Error="Invalid parm ID.  Enter Indent, Boxsize, Charbox or",
                "Fixlen"
          end

     Otherwise
          Error="Invalid parm ID.  Enter Indent, Boxsize, Charbox or",
                "Fixlen"
  end

 /* -------------------- *
  * Set description text *
  * -------------------- */
  if Datatype(cmtdfInd) = "NUM" then
     indd = " (Indent the comment box" cmtdfInd "characters)"
  if Pos(cmtdfInd,"cC") > 0   then
     indd = " (Comment box will be CENTERed based on RIGHT BOUNDS)"
  if Pos(cmtdfInd,"rR") > 0   then
     indd = " (Comment box will be RIGHT justified on RIGHT BOUNDS)"

  if Pos(cmtdfBox,"FS") > 0 then boxd =,
     " (Box size fixed at" cmtdfFix "characters. See FIXLEN setting)"
  if cmtdfBox="V" then boxd =,
  " (Box size based on longest comment line)"

  chrd = " (Box outlining character)"
  fixd = " (Box length When a Fixed/Set BOXSIZE used)"

 /* ----------------- *
  * Send Good message *
  * ----------------- */
  if Error = null then do
     zedsmsg = null
     zedlmsg = Left("CMT default values were set to:",81),
               Left(".    INDENT :" Left(cmtdfInd,2) " " indd,81),
               Left(".    BOXSIZE:" Left(cmtdfBox,2) " " boxd,81),
               Left(".    CHARBOX:" Left(cmtdfChr,2) " " chrd,81),
                    ".    FIXLEN :" Left(cmtdfFix,2) " " fixd
     end
  else do
 /* --------------------- *
  * Send an Error message *
  * --------------------- */
     zedsmsg = ' '
     zedlmsg = Left("Error setting default for '"parm_id"' ",
                    "SYNTAX: CMT SET <parmId> <dflt value>",81),
               Left(parm_id Error,81),
               Left("Current CMT defaults are:",81),
               Left(".    INDENT :" cmtdfInd " " indd,81),
               Left(".    BOXSIZE:" cmtdfBox " " boxd,81),
               Left(".    CHARBOX:" cmtdfChr " " chrd,81),
                    ".    FIXLEN :" Left(cmtdfFix,2) " " fixd
     end
 "Setmsg Msg(isrz000)"
 /* ---------------------------------------------------- *
  * Store the default values in the current PROFILE pool *
  * ---------------------------------------------------- */
 "Vput (cmtdfInd cmtdfBox cmtdfChr cmtdfFix) profile"

Return

/*========================================================*
 * Routine: Arrange_Parameters                            *
 *    Arrange parameters into indent,boxsize,text order,  *
 *    then assign the default to any null parameters.     *
 *    ASSUMPTION: at least one parm (indent) has a value. *
 *========================================================*/
Arrange_Parameters:

  Call Get_Default_Values

  text = text2
  Parse Value "" With indent_save box_save text_save

 /* ------------------------------- *
  * Check the current INDENT value. *
  * ------------------------------- */
  if Datatype(indent) = "NUM",
  |  Pos(indent,"cCrR") > 0 then Nop

  else
    /* -------------------------------- *
     * Move it to appropriate parameter *
     * since it is NOT the INDENT parm. *
     * -------------------------------- */
     if Wordpos(indent,Valid_Box_Values) > 0 then do
        box_save = indent
        indent = null
        end
     else do
        text_save = indent
        indent = null
     end

 /* -------------------------------- *
  * Check the current BOXSIXE value. *
  * -------------------------------- */
  if Wordpos(boxsize,Valid_Box_Values) = 0 then
    /* -------------------------------- *
     * Move it to appropriate parameter *
     * since it is NOT the BOXSIZE parm *
     * -------------------------------- */
     if Datatype(boxsize) = "NUM",
     |  Pos(boxsize,"cCrR") > 0 then do
        indent_save = boxsize
        boxsize = null
        end
     else do
        if boxsize \= null then do
           text_save = boxsize
           boxsize = null
        end
     end

 /* ----------------------------- *
  * Check the current TEXT value. *
  * ----------------------------- */
  if Wordpos(text,Valid_Box_Values) > 0 then do
     box_save = text
     text = null
     end

  if Datatype(text) = "NUM",
  |  Pos(text,"cCrR") > 0 then do
     indent_save = text
     text = null
     end

 /* ----------------------------------- *
  * Move in appropriate values for the  *
  * parms if they came in out of order. *
  * ----------------------------------- */
  if indent_save \= null then indent  = indent_save
  if box_save    \= null then boxsize = box_save
  if text_save   \= null then text    = text_save

Return

/*=============================================================*
 * Retrieve defaults for INDENT, BOXSIZE & CHARBOX  parameters *
 *=============================================================*/
Get_Default_Values:

  Address Ispexec "Vget (CmtdfInd CmtdfBox CmtdfChr CmtdfFix) profile"
  if CmtdfInd = null then CmtdfInd = 0
  if CmtdfBox = null then CmtdfBox = 'F'
  if CmtdfChr = null then CmtdfChr = '-'
  if CmtdfFix = null then CmtdfFix = 65

Return

/*==========================*
 * Display HELP information *
 *==========================*/
Get_Help:

  Call Get_Default_Values
  Call Create_Panels
  Address Ispexec
 "Addpop"
 "Display Panel(cmthelp)"
 "Rempop"

Return

/* ========================================================= *
 * Function: Create_Panels                                   *
 *    The following is a process to define panels in-line.   *
 *    Panels are defined and loaded into a temporary dataset *
 *    and then dataset is Libdef'ed so it is allocated.      *
 *    A deallocation of the Libdef happens in Exit_Macro.    *
 * ========================================================= */
Create_Panels:

 /* ---------------------------------------- *
  * If the panels have already been          *
  * created then bypass additional attempts. *
  * ---------------------------------------- */
  if Panels_Created then Return

 /* ---------------------------------------------- *
  * Create temp DS to hold inline panel definition *
  * ---------------------------------------------- */
  x = Msg(on)
  Address Tso
  prefix = Sysvar('SYSPREF')                  /* tso profile prefix  */
  uid    = Sysvar('SYSUID')                   /* tso userid          */
  if prefix =  '' then prefix = uid           /* use uid if null prfx*/
  if prefix <> '' & prefix <> uid then        /* diff prefix than uid*/
     prefix = prefix || '.' || uid            /*    use prefix.uid   */
  ddname = "$"Right(Time(S),7,"0")
  flname = prefix"."ddname".ISPPLIB"

 "Alloc File("ddname") da('"flname"') new del tracks space(1,1)",
       "lrecl(80) recfm(f b) blksize(3120) dir(1) reuse"

/* ------------------------------------ *
 * Three panels are created here.       *
 * CMTPANEL - Main comment entry panel. *
 * CMTHELP  - CMT command Help panel.   *
 * CMTHELPP - CMT panel Help panel.     *
 * ------------------------------------ */
  Call Create_Main_Panel
  Call Create_Help_Panels

  Panels_Created = 1
  Address Ispexec "libdef ispplib library id("ddname") stack"

Return

Create_Main_Panel:
  NEWSTACK
  mbname = "cmtpanel"

Queue ")Attr Default(%+{)                                           "
Queue " @ type(input) intens(high) caps(off) just(asis) color(white)",
      "    hilite(uscore)"
Queue " _ type(input) intens(high) caps(on)  just(asis) color(white)",
      "    hilite(uscore)"
Queue " $ type(output) intens(high) just(asis ) color(turq)             "
Queue " ~ type(text)   intens(high) caps(off) just(asis ) color(blue)   "
Queue " + type(text)   intens(low ) skip(on)                            "
Queue " { type(text)   intens(low ) skip(on)  color(green)              "
Queue ")Body                                                           "
Queue "+------------------%Comments Entry Ver$Z  +--------------------- "
Queue "+Command ===>_zcmd                             +Scroll ===>_zcsr+"
Queue "+                                                                "
Queue "%Parms:{Indent     :_Z {   Box Size   :_Z{                       "
Queue "+      {Fixed Size :_Z {   Boxing Char:_Z{    Set as defaults:_Z+"
Queue "+                                                                "
Queue "+      {Member Type:_Z    +   %END~add cmt %HELP %CANcel  Insert#"
Queue ")Model                                                           "
Queue ,
"+>@z                                                                +<"
Queue ")Init                                                            "
Queue "  &zcsr = CSR                                                    "
Queue "  .ZVARS = '(vernbr indent boxsize cmtdfFix cmtdfChr +           "
Queue "             setdflt mbrtype rxline)'                            "
Queue "  .cursor= mbrtype                                               "
Queue "  .help = cmthelpp                                               "
Queue "  &setdflt = 'N'                                                 "
Queue ")Proc                                                            "
Queue " ver (&mbrtype,LIST,'ASM','C','CLIST','COBOL','JCL',             "
Queue "  'PANEL','REXX','DOC','SAS','PLI','SKEL','SHELL')               "
Queue " ver (&boxsize,LIST,'C','F','S','V')                             "
Queue " ver (&cmtdfFix,RANGE,1,65)                                         "
Queue " ver (&setdflt,LIST,'Y','N')                                     "
Queue ")End                                                             "
Queue ""

  Call Write_Panel_Member

Return

Create_Help_Panels:
  NEWSTACK
  mbname = "cmthelp"

Queue ")Attr Default(%+_)                                              "
Queue " ~ type(text)   intens(high) caps(off) just(asis ) color(turq)  "
Queue " @ type(text)   intens(high) caps(off) just(asis ) color(yellow)"
Queue " $ type(output) intens(high) just(asis ) color(turq)             "
Queue " ` type(text)   intens(high) caps(off) just(asis ) color(red)   "
Queue ")Body Window(64,20)                                             "
Queue "+-----------------%CMT Command HELP  Ver$Z  +-------------------"
Queue "+Command ===>_zcmd                                              "
Queue "% CMT+is an ISPF edit macro to simplify entry of comments. CMT  "
Queue "+ enters all comments in the syntax of the object being edited  "
Queue "+ and formats them via sent/defaulted user parameters. Defaults "
Queue "+ for execution are set/inquired via the CMT syntax #2, shown   "
Queue "+ below, and some may be overridden via the main CMT syntax #1. "
Queue "` All comments require a target line be defined in your data.   "
Queue "~                                                               "
Queue "~ Syntax 1 to add comment line(s)    +(all parms optional)      "
Queue "% CMT #,B,text  +                                               "
Queue "%     #+=INDENT   %1+-%70, C+(Center) or%R+(Right Justify) box  "
Queue "%     B+=BOXSIZE  %F S+(Fixed$Z +chars) or %V+(Variable size)   "
Queue "%     cmt text+   @blank shows popup panel to enter mult lines. "
Queue "~                                                               "
Queue "~ Syntax 2 to Set CMT defaults @(also may be set on popup panel)"
Queue "% CMT SET <parmId> <parm value>                                 "
Queue "%     parmid    %Indent, Boxsize, Charbox or Fixlength          "
Queue "%     parm value+for I:%#1-70, C or R    +B:%F,S or V           "
Queue "%                   +C:%any character    +F:%1-65               "
Queue ")Init                                                           "
Queue "  .ZVARS = '(vernbr cmtdfFix)'                                  "
Queue ")End"
Queue ""

  Call Write_Panel_Member

  NEWSTACK
  mbname = "cmthelpp"

Queue ")Attr Default(%+_)                                              "
Queue " ~ type(text)   intens(high) caps(off) just(asis ) color(turq)  "
Queue " @ type(text)   intens(high) caps(off) just(asis ) color(yellow)"
Queue "   type(output) intens(high)                                    "
Queue " $ type(output) intens(high) just(asis ) color(turq)             "
Queue ")Body Window(64,20)                                             "
Queue "+------------------%CMT Panel HELP  Ver$Z  +--------------------"
Queue "+Command ===>_zcmd                                              "
Queue "+ Parameters shown are initially set with your default values.  "
Queue "+ They may be changed as needed for the comments to be added.   "
Queue "+ Enter 'Y' in%Set as defaults+to make the parms your defaults. "
Queue "%Cmds ~End+   text entered on panel is added to the source.     "
Queue "      ~Insert <n>+inserts <n> blank lines into displayed table. "
Queue "      ~Cancel+cancels with no comments added to the source.     "
Queue "%Indent     :+Valid:%1-70+ or %C+(Center box) %R+(Right Justify)"
Queue "            :+Enter how, or number of characters, to indent box."
Queue "%Box Size   :+Valid:%F+or%S+for a Fixed Size %V+- Variable.     "
Queue "              Fixed - box size set to the "Fixed Size" value.   "
Queue "              Variable - size set = to the longest line entered."
Queue "%Fixed Size :+Valid: nbr from%1-65 +Used ONLY if Box Size fixed."
Queue "%Boxing Char:+Character used as outside board of the box.       "
Queue "%Member type:+Language syntax to use When comments are added.   "
Queue "%Comments   :+Enter as many lines as needed. 150 lines initially"
Queue "             +given. Use command %Insert <n>+to add lines.      "
Queue "%For CMT command help enter CMT HELP while editing source.      "
Queue ")Init                                                           "
Queue "  .ZVARS = '(vernbr)'                                           "
Queue ")End"
Queue ""

  Call Write_Panel_Member

Return

Write_Panel_Member:

 "ALLOC File("mbname") SHR REUSE DA('"flname"("mbname")')"
 "EXECIO * DISKW" mbname "(FINIS"
 "FREE FI("mbname")"
  DELSTACK

Return
